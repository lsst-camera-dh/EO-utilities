#!/usr/bin/env python

import astropy.io.fits as fits
import os
from subprocess import Popen
import pyds9
import argparse
import sys
import glob
import numpy as np
from builtins import range

def fname(run, acq, img, seq, raft, ccd=None):
    #prefix = '/gpfs/slac/kipac/fs1/g/lsst/test_data/archive/LCA-10134_Cryostat/LCA-10134_Cryostat-0001/BOT_acq_sim/'
    # For now ignore the raft and run specification and point at raft test data
    prefix = '/gpfs/slac/lsst/fs1/g/data/jobHarness/jh_archive-test/LCA-11021_RTM/LCA-11021_RTM-010-Dev/5980D/'

    filepath = prefix + acq.lower() + '_raft_acq/v0/'
    if ccd is None:
        ccd = '*'  # if ccd is not specified, return a file for each CCD in the raft
    glob_str = filepath + '*/' + ccd + '/*' + acq.lower() + '_*' + img.lower() + '_' + seq.zfill(3) + '*'
    #print(glob_str)
    files = glob.glob(glob_str)
    files.sort()
    return files 
    
tempfile = '/scratch/temp_' + os.environ['USER'] + '.fits'
# Example command lines
# -run 9999 -acq DARK -img DARK -seq 3 -raft R22 -ccd S11 -seg 10 -over
# -run 9999 -acq DARK -img DARK -seq 3 -raft R22

parser = argparse.ArgumentParser(description='Display a CCD image.')
parser.add_argument('-run', help='run number')
parser.add_argument('-acq', choices=['BIAS','DARK','FE55','FLAT','LAMBDA','SFLAT','FE55_FLAT','XTALK','CCOB','SPOT','SPOT_FLAT','PERSISTENCE','TRAP','SCAN'],help='acquisition type')
parser.add_argument('-img', choices=['BIAS','DARK','FE55','FLAT1','FLAT2','PPUMP'],help='image type')
parser.add_argument('-seq',help='sequence number')
parser.add_argument('-raft',choices=['R10','R20','R30','R01','R11','R21','R31','R41','R02','R12','R22','R32','R42','R03','R13','R23','R33','R43','R14','R24','R34'], help='raft coordinates in focal plane')
parser.add_argument('-ccd', choices=['S00','S01','S02','S10','S11','S12','S20','S21','S22'], help='CCD slot in raft')
parser.add_argument('-seg',choices=['01','02','03','04','05','06','07','10','11','12','13','14','15','16','17'], help='CCD segment number')
parser.add_argument('-over', action='store_const', const=1)

args = parser.parse_args()

files = fname(args.run, args.acq, args.img, args.seq, args.raft, args.ccd)

if len(files) == 0:
    print('No matching files found')

elif args.seg is not None:
    if len(files) > 1:
        print('Too many files for an individual CCD segment display:  '  + str(len(files)))

    elif args.over is None:
        # display without overscan
        d = pyds9.DS9()  #start='--mosaicimage iraf')
        d.set('file ' + files[0] + '[Segment' + args.seg + ']')
        d.set('zoom to fit')
            
    else:
        # display with overscan
        # (edit the header keywords)
        hdulist = fits.HDUList()

        # Take primary header from the file [taken to be the first if >1 file was found]
        hdu = fits.open(files[0])
        # Extract the CCD_MANU keyword
        ccdtype = hdu[0].header['CCD_MANU']
        hdulist.append(hdu[0])

        sensor_loc = 'S' + files[0].split('/S')[1].split('/')[0]

        for i in list(range(1,17)):
            hdutemp = hdu[i]
            # Extract NAXIS1, NAXIS2, and the EXTNAME to redefine
            # DATASEC and DETSEC # to select the entire segment,
            # and still have it assembled with the correct
            # orientation and relative placement in ds9
            naxis1 = hdutemp.header['NAXIS1']
            naxis2 = hdutemp.header['NAXIS2']
            extname = hdutemp.header['EXTNAME']
            # Extract Sx, Sy (Segment 'x' and 'y' addresses) from EXTNAME
            Sx, Sy = int(extname[7]), int(extname[8])
            Sp, Ss = Sx, Sy  # for convenience of notation
            dimh, dimv = naxis1, naxis2
            ccdax, ccday = dimv*2, dimh*8
            # Equations below are from LCA-13501
            if ccdtype is 'E2V':
                dsx1 = (Sy*dimh + 1)*(1 - Sx) + (Sy + 1)*dimh*Sx
                dsx2 = (Sy + 1)*dimh*(1 - Sx) + (Sy*dimh + 1)*Sx
                dsy1 = 2*dimv*(1 - Sx) + Sx
                dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
            else:
                dsx1 = (Sy + 1)*dimh
                dsx2 = Sy*dimh + 1
                dsy1 = 2*dimv*(1 - Sx) + Sx
                dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                gap_outx, gap_outy = 26, 26

            datasec = '[1:' + str(naxis1) + ',1:' + str(naxis2) + ']'
            detsec = '[' + str(dsx1) + ':' + str(dsx2) + ',' + str(dsy1) + ':' + str(dsy2) + ']'
            detsize = '[1:' + str(naxis1*8) + ',1:' + str(naxis2*2) + ']'
            hdutemp.header['DATASEC'] = datasec
            hdutemp.header['DETSEC'] = detsec
            hdutemp.header['DETSIZE'] = detsize
            hdutemp.header.set('EXTNAME', sensor_loc + '_' +
                               hdutemp.header['EXTNAME'])
            hdulist.append(hdutemp)

        hdulist.writeto(tempfile, overwrite=True)
        d = pyds9.DS9()  #start='--mosaicimage iraf')
        d.set('file ' + tempfile + '[' + sensor_loc + '_Segment' + args.seg + ']')
        d.set('scale mode zscale')
        d.set('zoom to fit')

elif args.ccd is not None:
    if len(files) > 1:
        print('Too many files for an individual CCD display:  '  + str(len(files)))
    elif args.over is None:
        # display without overscan
        d = pyds9.DS9()
        d.set('mosaicimage wcsb ' + files[0])
        d.set('view wcsb')  # Display a continuous pixel coordinate system
        d.set('scale mode zscale')
        d.set('zoom to fit')
        d.set('rotate 180')
            
    else:
        # display with overscan
        # Assemble the CCD image with the overscans included (below from
        # merge_over.py)

        hdulist = fits.HDUList()

        # Take primary header from the file [taken to be the first if >1 file was found]
        hdu = fits.open(files[0])
        # Extract the CCD_MANU keyword
        ccdtype = hdu[0].header['CCD_MANU']
        hdulist.append(hdu[0])
        preh, overh = 0, 0  # notation of LCA-13501 - no pre- or over-scan
        overv = 0

        sensor_loc = 'S' + files[0].split('/S')[1].split('/')[0]

        for i in list(range(1,17)):
            hdutemp = hdu[i]
            # Extract NAXIS1, NAXIS2, and the EXTNAME to redefine
            # DATASEC and DETSEC # to select the entire segment,
            # and still have it assembled with the correct
            # orientation and relative placement in ds9
            naxis1 = hdutemp.header['NAXIS1']
            naxis2 = hdutemp.header['NAXIS2']
            extname = hdutemp.header['EXTNAME']
            # Extract Sx, Sy (Segment 'x' and 'y' addresses) from EXTNAME
            Sx, Sy = int(extname[7]), int(extname[8])
            Sp, Ss = Sx, Sy  # for convenience of notation
            dimh, dimv = naxis1, naxis2
            ccdax, ccday = dimv*2, dimh*8
            # Equations below are from LCA-13501
            if ccdtype is 'E2V':
                dsx1 = (Sy*dimh + 1)*(1 - Sx) + (Sy + 1)*dimh*Sx
                dsx2 = (Sy + 1)*dimh*(1 - Sx) + (Sy*dimh + 1)*Sx
                dsy1 = 2*dimv*(1 - Sx) + Sx
                dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                crval1b = Sp*(dimh+1) + Ss*dimh + (2*Sp-1)*preh
                crval2b = Sp*(2*dimv + 1)
            else:
                dsx1 = (Sy + 1)*dimh
                dsx2 = Sy*dimh + 1
                dsy1 = 2*dimv*(1 - Sx) + Sx
                dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                gap_outx, gap_outy = 26, 26
                crval1b = (Ss+1)*dimh + 1 - preh
                crval2b = Sp*(2*dimv + 1)

            datasec = '[1:' + str(naxis1) + ',1:' + str(naxis2) + ']'
            detsec = '[' + str(dsx1) + ':' + str(dsx2) + ',' + str(dsy1) + ':' + str(dsy2) + ']'
            detsize = '[1:' + str(naxis1*8) + ',1:' + str(naxis2*2) + ']'
            hdutemp.header['DATASEC'] = datasec
            hdutemp.header['DETSEC'] = detsec
            hdutemp.header['DETSIZE'] = detsize
            hdutemp.header['CRVAL1B'] = crval1b
            hdutemp.header['CRVAL2B'] = crval2b
            hdutemp.header.set('EXTNAME', sensor_loc + '_' +
                               hdutemp.header['EXTNAME'])
            hdulist.append(hdutemp)

        hdulist.writeto(tempfile, overwrite=True)
        d = pyds9.DS9()  #start='--mosaicimage iraf')
        d.set('mosaicimage wcsb ' + tempfile)
        d.set('scale mode zscale')
        d.set('view wcsb')  # Display a continuous pixel coordinate system
        d.set('zoom to fit')
        d.set('rotate 180') # Rotate to DM convention

elif args.raft is not None:
    if len(files) != 9:
        print('Should be nine files for a raftdisplay:  '  + str(len(files)))
    elif args.over is None:
        # assemble the raft image (below from merge.py)
        hdulist = fits.HDUList()

        # Take primary header from the first file in the list
        hdu = fits.open(files[0])
        hdulist.append(hdu[0])

        for infile in files:
            hdu = fits.open(infile)
            sensor_loc = 'S' + infile.split('/S')[1].split('/')[0]
            for i in list(range(1,17)):
                hdu[i].header.set('EXTNAME', sensor_loc + '_' +
                                  hdu[i].header['EXTNAME'])
                hdulist.append(hdu[i])

        hdulist.writeto(tempfile, overwrite=True)
        d = pyds9.DS9()  #start='--mosaicimage iraf')
        d.set('mosaicimage wcsq ' + tempfile)
        d.set('scale mode zscale')
        d.set('view wcsq')
        d.set('zoom to fit')
        d.set('rotate 180')
    else:
        # Assemble the raft image with the overscans included (below from
        # merge_over.py)

        hdulist = fits.HDUList()

        # Take primary header from the first file in the list
        hdu = fits.open(files[0])
        # Extract the CCD_MANU keyword
        ccdtype = hdu[0].header['CCD_MANU']
        hdulist.append(hdu[0])
        preh, overh = 0, 0  # notation of LCA-13501 - no pre- or over-scan
        overv = 0

        count = 0
        for count, infile in enumerate(files):
            hdu = fits.open(infile)
            sensor_loc = 'S' + infile.split('/S')[1].split('/')[0]

            # Notation below is from LCA-13501
            Cp = np.divide(count, 3)
            Cs = count - 3*Cp  # modulo

            for i in list(range(1,17)):
                hdutemp = hdu[i]
                # Extract NAXIS1, NAXIS2, and the EXTNAME to redefine
                # DATASEC and DETSEC # to select the entire segment,
                # and still have it assembled with the correct
                # orientation and relative placement in ds9
                naxis1 = hdutemp.header['NAXIS1']
                naxis2 = hdutemp.header['NAXIS2']
                extname = hdutemp.header['EXTNAME']
                # Extract Sx, Sy (Segment 'x' and 'y' addresses) from EXTNAME
                Sx, Sy = int(extname[7]), int(extname[8])
                Sp, Ss = Sx, Sy  # for convenience of notation
                dimh, dimv = naxis1, naxis2
                ccdax, ccday = dimv*2, dimh*8
                # Equations below are from LCA-13501
                if ccdtype is 'E2V':
                    dsx1 = (Sy*dimh + 1)*(1 - Sx) + (Sy + 1)*dimh*Sx
                    dsx2 = (Sy + 1)*dimh*(1 - Sx) + (Sy*dimh + 1)*Sx
                    dsy1 = 2*dimv*(1 - Sx) + Sx
                    dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                    ccdpx, ccdpy = ccdax + 193, ccday + 104
                    gap_inx, gap_iny = 28, 25
                    gap_outx, gap_outy = 26.5, 25
                    crval1q = gap_outy + (ccdpy - ccday)//2 + Cs*(8*dimh + gap_iny + ccdpy - ccday) + Sp*(dimh + 1) + Ss*dimh + (2*Sp - 1)*preh
                    crval2q = Sp*(2*dimv + 1) + gap_outx + (ccdpx - ccdax)//2 + Cp*(2*dimv + gap_inx + ccdpx - ccdax)
                else:
                    dsx1 = (Sy + 1)*dimh
                    dsx2 = Sy*dimh + 1
                    dsy1 = 2*dimv*(1 - Sx) + Sx
                    dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                    ccdpx, ccdpy = ccdax + 198, ccday + 126
                    gap_inx, gap_iny = 27, 27
                    gap_outx, gap_outy = 26, 26
                    crval1q = gap_outy + (ccdpy - ccday)//2 + Cs*(8*dimh + gap_iny + ccdpy - ccday) + (Ss + 1)*dimh + 1 - preh
                    crval2q = Sp*(2*dimv + 1) + gap_outx + (ccdpx - ccdax)//2 + Cp*(2*dimv + gap_inx + ccdpx - ccdax)

                datasec = '[1:' + str(naxis1) + ',1:' + str(naxis2) + ']'
                detsec = '[' + str(dsx1) + ':' + str(dsx2) + ',' + str(dsy1) + ':' + str(dsy2) + ']'
                detsize = '[1:' + str(naxis1*8) + ',1:' + str(naxis2*2) + ']'
                hdutemp.header['DATASEC'] = datasec
                hdutemp.header['DETSEC'] = detsec
                hdutemp.header['DETSIZE'] = detsize
                hdutemp.header['CRVAL1Q'] = crval1q
                hdutemp.header['CRVAL2Q'] = crval2q
                hdutemp.header.set('EXTNAME', sensor_loc + '_' +
                                   hdutemp.header['EXTNAME'])
                hdulist.append(hdutemp)

        hdulist.writeto(tempfile, overwrite=True)
        d = pyds9.DS9()  #start='--mosaicimage iraf')
        d.set('mosaicimage wcsq ' + tempfile)
        d.set('scale mode zscale')
        d.set('view wcsq')  # Display a continuous pixel coordinate system
        d.set('zoom to fit')
        d.set('rotate 180') # Rotate to DM convention

else:
    print('Problem')
