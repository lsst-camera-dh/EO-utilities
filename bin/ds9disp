#!/usr/bin/env python

import astropy.io.fits as fits
import os
from subprocess import Popen
import pyds9
import argparse
import sys
import glob
import numpy as np
from builtins import range

def fname(run, acq, img, seq, raft, exptime=None, filt=None, ccd=None):
    #prefix = '/gpfs/slac/kipac/fs1/g/lsst/test_data/archive/LCA-10134_Cryostat/LCA-10134_Cryostat-0001/BOT_acq_sim/'
    # For now ignore the raft specification and point at TS8 data for RTM-010

    # below is for raft test data (TS8)
    #prefix = '/gpfs/slac/lsst/fs1/g/data/jobHarness/jh_archive-test/LCA-11021_RTM/LCA-11021_RTM-010-Dev/'
    #if ccd is None:
        #ccd = '*'  # if ccd is not specified, return a file for each CCD in the raft

    #if acq.lower() == 'flat':
        #filepath = prefix + run + '/' + acq.lower() + '_pair_raft_acq/v0/'
        #glob_str = filepath + '*/' + ccd + '/*' + acq.lower() + '_' + seq +'_' + img.lower() + '_*'
    #else:
        #filepath = prefix + run + '/' + acq.lower() + '_raft_acq/v0/'
        #glob_str = filepath + '*/' + ccd + '/*' + acq.lower() + '_*' + img.lower() + '_' + seq.zfill(3) + '*'

    prefix = '/gpfs/slac/lsst/fs3/g/data/jobHarness/jh_archive-test/LCA-10134_Cryostat/LCA-10134_Cryostat-0001/'
    if ccd is None:
        ccd = '*'  # if ccd is not specified, return a file for each CCD in the raft

    #if acq.lower() == 'flat':
    #    filepath = prefix + run + '/' + acq.lower() + '_pair_raft_acq/v0/'
    #    glob_str = filepath + '*/' + ccd + '/*' + acq.lower() + '_' + seq +'_' + img.lower() + '_*'
    #else:
    if acq.lower() == 'lambda':
        glob_str = prefix + run + '/BOT_acq/v0/*/' + acq.lower() + '_' + img.lower() + '_*' + seq.zfill(3) + '/MC_C*' + raft + '_' + ccd + '.fits'
    elif acq.lower() == 'fe55_flat':
        if filt is None:
            filt = '*'
        if exptime is None:
            exptime = '*'
        glob_str = prefix + run + '/BOT_acq/v0/*/' + acq.lower() + '_' + filt + '_' + img.lower() + '_' + exptime + '_' + seq.zfill(3) + '/MC_C*' + raft + '_' + ccd + '.fits'
    else:
        glob_str = prefix + run + '/BOT_acq/v0/*/' + acq.lower() + '_*' + img.lower() + '_' + seq.zfill(3) + '/MC_C*' + raft + '_' + ccd + '.fits'
    print(glob_str)
    files = glob.glob(glob_str)
    files.sort()
    
    return files 
    
tempfile = '/tmp/temp_' + os.environ['USER'] + '.fits'
# Example command lines
# -run 9999 -acq DARK -img DARK -seq 3 -raft R22 -ccd S11 -seg 10 -over
# -run 9999 -acq DARK -img DARK -seq 3 -raft R22

parser = argparse.ArgumentParser(description='Display a CCD image.')
parser.add_argument('-run', help='run number')
parser.add_argument('-acq', choices=['bias','dark','flat','lambda','sflat','fe55_flat','xtalk','ccob','spot','spot_flat','persistence','trap','scan'],help='acquisition type', type=str.lower)
parser.add_argument('-img', choices=['bias','dark','fe55','flat','flat_0','flat_1','flat_2','ppump'],help='image type', type=str.lower)
parser.add_argument('-seq',help='sequence number', type=str.lower)
parser.add_argument('-raft',choices=['R10','R20','R30','R01','R11','R21','R31','R41','R02','R12','R22','R32','R42','R03','R13','R23','R33','R43','R14','R24','R34'], help='raft coordinates in focal plane')
parser.add_argument('-ccd', choices=['S00','S01','S02','S10','S11','S12','S20','S21','S22'], help='CCD slot in raft')
parser.add_argument('-seg',choices=['01','02','03','04','05','06','07','10','11','12','13','14','15','16','17'], help='CCD segment number')
parser.add_argument('-filter', choices=['480nm', '650nm', '750nm', '870nm', '950nm', '970nm', 'SDSSu', 'SDSSg', 'SDSSr', 'SDSSi',' SDSSz', 'SDSSY'])
parser.add_argument('-exp', help='exposure time for flat in s (no units)', type=str)
parser.add_argument('-over', action='store_const', const=1)

args = parser.parse_args()

# Allow for the possibility of a sequence of run numbers and/or sequence numbers
num_frames = len(args.seq.split(','))*len(args.run.split(','))

frame = 1
d = pyds9.DS9()  #start='--mosaicimage iraf')

for seq in args.seq.split(','):
    for run in args.run.split(','):
        files = fname(run, args.acq, args.img, seq, args.raft, args.exp, args.filter, args.ccd)

        if len(files) == 0:
            print('No matching files found')

        elif args.seg is not None:
            if len(files) > 1:
                print('Too many files for an individual CCD segment display:  '  + str(len(files)))

            elif args.over is None:
                # display without overscan
                d.set('file ' + files[0] + '[Segment' + args.seg + ']')
                #d.set('zoom to fit')
            
            else:
                # display with overscan
                # (edit the header keywords)
                hdulist = fits.HDUList()

                # Take primary header from the file [taken to be the first if >1 file was found]
                hdu = fits.open(files[0])
                # Extract the CCD_MANU keyword
                ccdtype = hdu[0].header['CCD_MANU']
                hdulist.append(hdu[0])

                #sensor_loc = 'S' + files[0].split('/S')[1].split('/')[0]
                # below for BOT data
                sensor_loc = 'S' + infile.split('.fits')[0][-2:]
                print(sensor_loc)

                for i in list(range(1,17)):
                    hdutemp = hdu[i]
                    # Extract NAXIS1, NAXIS2, and the EXTNAME to redefine
                    # DATASEC and DETSEC # to select the entire segment,
                    # and still have it assembled with the correct
                    # orientation and relative placement in ds9
                    naxis1 = hdutemp.header['NAXIS1']
                    naxis2 = hdutemp.header['NAXIS2']
                    extname = hdutemp.header['EXTNAME']
                    # Extract Sx, Sy (Segment 'x' and 'y' addresses) from EXTNAME
                    Sx, Sy = int(extname[7]), int(extname[8])
                    Sp, Ss = Sx, Sy  # for convenience of notation
                    dimh, dimv = naxis1, naxis2
                    ccdax, ccday = dimv*2, dimh*8
                    # Equations below are from LCA-13501
                    if ccdtype is 'E2V':
                        dsx1 = (Sy*dimh + 1)*(1 - Sx) + (Sy + 1)*dimh*Sx
                        dsx2 = (Sy + 1)*dimh*(1 - Sx) + (Sy*dimh + 1)*Sx
                        dsy1 = 2*dimv*(1 - Sx) + Sx
                        dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                    else:
                        dsx1 = (Sy + 1)*dimh
                        dsx2 = Sy*dimh + 1
                        dsy1 = 2*dimv*(1 - Sx) + Sx
                        dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                        gap_outx, gap_outy = 26, 26

                    datasec = '[1:' + str(naxis1) + ',1:' + str(naxis2) + ']'
                    detsec = '[' + str(dsx1) + ':' + str(dsx2) + ',' + str(dsy1) + ':' + str(dsy2) + ']'
                    detsize = '[1:' + str(naxis1*8) + ',1:' + str(naxis2*2) + ']'
                    hdutemp.header['DATASEC'] = datasec
                    hdutemp.header['DETSEC'] = detsec
                    hdutemp.header['DETSIZE'] = detsize
                    hdutemp.header.set('EXTNAME', sensor_loc + '_' +
                                       hdutemp.header['EXTNAME'])
                    hdulist.append(hdutemp)

                hdulist.writeto(tempfile, overwrite=True)
                #d = pyds9.DS9()  #start='--mosaicimage iraf')
                d.set('file ' + tempfile + '[' + sensor_loc + '_Segment' + args.seg + ']')
                d.set('scale mode zscale')
                #d.set('zoom to fit')

        elif args.ccd is not None:
            if len(files) > 1:
                print('Too many files for an individual CCD display:  '  + str(len(files)))
            elif args.over is None:
                # display without overscan
                #d = pyds9.DS9()
                d.set('mosaicimage wcsb ' + files[0])
                d.set('view wcsb')  # Display a continuous pixel coordinate system
                d.set('scale mode zscale')
                #d.set('zoom to fit')
                d.set('rotate 180')
            
            else:
                # display with overscan
                # Assemble the CCD image with the overscans included (below from
                # merge_over.py)

                hdulist = fits.HDUList()

                # Take primary header from the file [taken to be the first if >1 file was found]
                hdu = fits.open(files[0])
                # Extract the CCD_MANU keyword
                ccdtype = hdu[0].header['CCD_MANU']
                hdulist.append(hdu[0])
                preh, overh = 0, 0  # notation of LCA-13501 - no pre- or over-scan
                overv = 0

                #sensor_loc = 'S' + files[0].split('/S')[1].split('/')[0]
                # below for BOT data
                sensor_loc = 'S' + infile.split('.fits')[0][-2:]

                for i in list(range(1,17)):
                    hdutemp = hdu[i]
                    # Extract NAXIS1, NAXIS2, and the EXTNAME to redefine
                    # DATASEC and DETSEC # to select the entire segment,
                    # and still have it assembled with the correct
                    # orientation and relative placement in ds9
                    naxis1 = hdutemp.header['NAXIS1']
                    naxis2 = hdutemp.header['NAXIS2']
                    extname = hdutemp.header['EXTNAME']
                    # Extract Sx, Sy (Segment 'x' and 'y' addresses) from EXTNAME
                    Sx, Sy = int(extname[7]), int(extname[8])
                    Sp, Ss = Sx, Sy  # for convenience of notation
                    dimh, dimv = naxis1, naxis2
                    ccdax, ccday = dimv*2, dimh*8
                    # Equations below are from LCA-13501
                    if ccdtype is 'E2V':
                        dsx1 = (Sy*dimh + 1)*(1 - Sx) + (Sy + 1)*dimh*Sx
                        dsx2 = (Sy + 1)*dimh*(1 - Sx) + (Sy*dimh + 1)*Sx
                        dsy1 = 2*dimv*(1 - Sx) + Sx
                        dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                        crval1b = Sp*(dimh+1) + Ss*dimh + (2*Sp-1)*preh
                        crval2b = Sp*(2*dimv + 1)
                    else:
                        dsx1 = (Sy + 1)*dimh
                        dsx2 = Sy*dimh + 1
                        dsy1 = 2*dimv*(1 - Sx) + Sx
                        dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                        gap_outx, gap_outy = 26, 26
                        crval1b = (Ss+1)*dimh + 1 - preh
                        crval2b = Sp*(2*dimv + 1)

                    datasec = '[1:' + str(naxis1) + ',1:' + str(naxis2) + ']'
                    detsec = '[' + str(dsx1) + ':' + str(dsx2) + ',' + str(dsy1) + ':' + str(dsy2) + ']'
                    detsize = '[1:' + str(naxis1*8) + ',1:' + str(naxis2*2) + ']'
                    hdutemp.header['DATASEC'] = datasec
                    hdutemp.header['DETSEC'] = detsec
                    hdutemp.header['DETSIZE'] = detsize
                    hdutemp.header['CRVAL1B'] = crval1b
                    hdutemp.header['CRVAL2B'] = crval2b
                    hdutemp.header.set('EXTNAME', sensor_loc + '_' +
                                       hdutemp.header['EXTNAME'])
                    hdulist.append(hdutemp)

                hdulist.writeto(tempfile, overwrite=True)
                d = pyds9.DS9()  #start='--mosaicimage iraf')
                d.set('mosaicimage wcsb ' + tempfile)
                d.set('scale mode zscale')
                d.set('view wcsb')  # Display a continuous pixel coordinate system
                #d.set('zoom to fit')
                d.set('rotate 180') # Rotate to DM convention

        elif args.raft is not None:
            if len(files) != 9:
                print('Should be nine files for a raftdisplay:  '  + str(len(files)))
            elif args.over is None:
                # assemble the raft image (below from merge.py)
                hdulist = fits.HDUList()

                # Take primary header from the first file in the list
                hdu = fits.open(files[0])
                hdulist.append(hdu[0])

                for infile in files:
                    hdu = fits.open(infile)
                    # below for raft-level data
                    #sensor_loc = 'S' + infile.split('/S')[1].split('/')[0]
                    # below for BOT data
                    sensor_loc = 'S' + infile.split('.fits')[0][-2:]
                    for i in list(range(1,17)):
                        hdu[i].header.set('EXTNAME', sensor_loc + '_' +
                                          hdu[i].header['EXTNAME'])
                        hdulist.append(hdu[i])

                hdulist.writeto(tempfile, overwrite=True)
                #d = pyds9.DS9()  #start='--mosaicimage iraf')
                d.set('width 900')
                d.set('height 800')
                d.set('mosaicimage wcsq ' + tempfile)
                d.set('scale mode zscale')
                d.set('view wcsq')
                #d.set('zoom to fit')
                d.set('rotate 180')
            else:
                # Assemble the raft image with the overscans included (below from
                # merge_over.py)

                hdulist = fits.HDUList()

                # Take primary header from the first file in the list
                hdu = fits.open(files[0])
                # Extract the CCD_MANU keyword
                ccdtype = hdu[0].header['CCD_MANU']
                hdulist.append(hdu[0])
                preh, overh = 0, 0  # notation of LCA-13501 - no pre- or over-scan
                overv = 0

                count = 0
                for count, infile in enumerate(files):
                    hdu = fits.open(infile)
                    #sensor_loc = 'S' + infile.split('/S')[1].split('/')[0]
                    # below for BOT data
                    sensor_loc = 'S' + infile.split('.fits')[0][-2:]

                    # Notation below is from LCA-13501
                    Cp = count // 3 
                    Cs = count - 3*Cp  # modulo

                    for i in list(range(1,17)):
                        hdutemp = hdu[i]
                        # Extract NAXIS1, NAXIS2, and the EXTNAME to redefine
                        # DATASEC and DETSEC # to select the entire segment,
                        # and still have it assembled with the correct
                        # orientation and relative placement in ds9
                        naxis1 = hdutemp.header['NAXIS1']
                        naxis2 = hdutemp.header['NAXIS2']
                        extname = hdutemp.header['EXTNAME']
                        # Extract Sx, Sy (Segment 'x' and 'y' addresses) from EXTNAME
                        Sx, Sy = int(extname[7]), int(extname[8])
                        Sp, Ss = Sx, Sy  # for convenience of notation
                        dimh, dimv = naxis1, naxis2
                        ccdax, ccday = dimv*2, dimh*8
                        # Equations below are from LCA-13501
                        if ccdtype is 'E2V':
                            dsx1 = (Sy*dimh + 1)*(1 - Sx) + (Sy + 1)*dimh*Sx
                            dsx2 = (Sy + 1)*dimh*(1 - Sx) + (Sy*dimh + 1)*Sx
                            dsy1 = 2*dimv*(1 - Sx) + Sx
                            dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                            ccdpx, ccdpy = ccdax + 193, ccday + 104
                            gap_inx, gap_iny = 28, 25
                            gap_outx, gap_outy = 26.5, 25
                            crval1q = gap_outy + (ccdpy - ccday)//2 + Cs*(8*dimh + gap_iny + ccdpy - ccday) + Sp*(dimh + 1) + Ss*dimh + (2*Sp - 1)*preh
                            crval2q = Sp*(2*dimv + 1) + gap_outx + (ccdpx - ccdax)//2 + Cp*(2*dimv + gap_inx + ccdpx - ccdax)
                        else:
                            dsx1 = (Sy + 1)*dimh
                            dsx2 = Sy*dimh + 1
                            dsy1 = 2*dimv*(1 - Sx) + Sx
                            dsy2 = (dimv + 1)*(1 - Sx) + dimv*Sx
                            ccdpx, ccdpy = ccdax + 198, ccday + 126
                            gap_inx, gap_iny = 27, 27
                            gap_outx, gap_outy = 26, 26
                            crval1q = gap_outy + (ccdpy - ccday)//2 + Cs*(8*dimh + gap_iny + ccdpy - ccday) + (Ss + 1)*dimh + 1 - preh
                            crval2q = Sp*(2*dimv + 1) + gap_outx + (ccdpx - ccdax)//2 + Cp*(2*dimv + gap_inx + ccdpx - ccdax)

                        datasec = '[1:' + str(naxis1) + ',1:' + str(naxis2) + ']'
                        detsec = '[' + str(dsx1) + ':' + str(dsx2) + ',' + str(dsy1) + ':' + str(dsy2) + ']'
                        detsize = '[1:' + str(naxis1*8) + ',1:' + str(naxis2*2) + ']'
                        hdutemp.header['DATASEC'] = datasec
                        hdutemp.header['DETSEC'] = detsec
                        hdutemp.header['DETSIZE'] = detsize
                        hdutemp.header['CRVAL1Q'] = crval1q
                        hdutemp.header['CRVAL2Q'] = crval2q
                        hdutemp.header.set('EXTNAME', sensor_loc + '_' +
                                           hdutemp.header['EXTNAME'])
                        hdulist.append(hdutemp)

                hdulist.writeto(tempfile, overwrite=True)
                #d = pyds9.DS9()  #start='--mosaicimage iraf')
                d.set('mosaicimage wcsq ' + tempfile)
                d.set('scale mode zscale')
                d.set('view wcsq')  # Display a continuous pixel coordinate system
                #d.set('zoom to fit')
                d.set('rotate 180') # Rotate to DM convention

        else:
            print('Problem')
        if frame < num_frames:
            d.set('frame new')
            frame += 1

if num_frames > 1:
    d.set('tile yes')

if num_frames > 0:
    for frame in range(1,num_frames+1):
        d.set('frame %s' % frame)
        d.set('zoom to fit')
